# -*- coding: utf-8 -*-
"""CNN_trial.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1W__Je5TxKn1dr4cTaifLc1fuUov6JlwJ
"""

gpu_info = !nvidia-smi
gpu_info = '\n'.join(gpu_info)
if gpu_info.find('failed') >= 0:
  print('Not connected to a GPU')
else:
  print(gpu_info)

!pip install tensorflow
!pip install keras

import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow.keras import datasets,layers,models
import matplotlib.pyplot as plt

(xtrain,ytrain),(xtest,ytest)=datasets.cifar10.load_data()

ytest=ytest.reshape(-1,)
ytest

classname=["airplane","automobile","bird","cat","deer","dog","frog","horse","ship","truck"]

def example(x,y,index):
    plt.figure(figsize=(15,2))
    plt.imshow(x[index])
    plt.xlabel(classname[y[index]])

#x: Dataset containing the images.
#y: Dataset containing the labels. Specifies the class of each image.
#index: Specify the index of the data point to be visualized

example(xtest,ytest,8)

example(xtest,ytest,10)

example(xtest,ytest,200)

"""## Normalization Operations

"""

xtrain=xtrain/255
xtest=xtest/255

from keras.layers import Input

model = models.Sequential([
    Input(shape=(32,32,3)),  # InputLayer'Ä± buraya ekleyin
    layers.Conv2D(filters=32, kernel_size=(3,3), activation='relu'),
    layers.MaxPooling2D(2,2),

    layers.Conv2D(filters=64, kernel_size=(3,3), activation='relu'),
    layers.MaxPooling2D(2,2),

    layers.Flatten(),
    layers.Dense(64, activation="relu"),
    layers.Dense(10, activation="softmax")
])

model

model.summary()

from tensorflow.keras.utils import plot_model
# or from keras.utils import plot_model

plot_model(
    model,
    to_file='model_plot.png',
    show_shapes=True,
    show_layer_names=True,
    show_dtype=True,            # Optionally shows layer dtypes
    expand_nested=True,         # Expands nested models if any
    show_layer_activations=True # Shows activation functions
)

model.save('my_model.h5')  # or model.save('my_model') for TensorFlow SavedModel format

model.compile(optimizer="adam",
              loss="sparse_categorical_crossentropy",
              metrics=["accuracy"])

"""## Training the Model"""

history=model.fit(xtrain,ytrain,epochs=30, validation_data=(xtest,ytest))

loss,acc= model.evaluate(xtest,ytest,verbose=False)

plt.figure(figsize=(20,5))
plt.subplot(1,2,1)
plt.plot(history.history['accuracy'],color = "b",label= "Training Accuracy")
plt.plot(history.history["val_accuracy"], color = "r", label = "Validation Accuracy")
plt.legend(loc = "lower right")
plt.xlabel("Epoch", fontsize= 16)
plt.ylabel("Accuracy",fontsize = 16)
plt.ylim([min(plt.ylim()),1])
plt.title("Training and Test Performance Graph", fontsize = 16)

plt.figure(figsize= (20,5))
plt.subplot(1,2,2)
plt.plot(history.history["loss"],color= "b",label="Training Loss")
plt.plot(history.history["val_loss"],color="r",label="Validation Loss")
plt.legend(loc= "upper right")
plt.xlabel("Epoch",fontsize=16)
plt.ylabel("Loss",fontsize = 16)
plt.ylim([0,max(plt.ylim())])
plt.title("Training and Test Loss Graph",fontsize= 16)
plt.show()

ypred=model.predict(xtest)
ypred[:3]

ypred1=[np.argmax(element) for element in ypred]
ypred1[:3]

# True classes
y_true = [3, 8, 8, 0]

# Predicted classes
ypred1 = [3, 8, 1, 0]

# Printing the true and predicted classes
for true, pred in zip(y_true[:3], ypred1[:3]):
    print("True Class:", classname[true], "\tPredicted Class:", classname[pred])

from sklearn.metrics import classification_report

# Assuming y_true and ypred1 contain only labels from 0 to 9
# Extract unique labels from y_true and ypred1
unique_labels = sorted(list(set(y_true + ypred1)))

# Select corresponding target names for the unique labels
selected_target_names = [classname[label] for label in unique_labels]

# Generate the classification report using the selected target names
print(classification_report(y_true, ypred1, target_names=selected_target_names))

import matplotlib.pyplot as plt


ypred = model.predict(xtest)  # Get predictions for the test set
ypred1 = [np.argmax(element) for element in ypred]  # Get predicted class labels

# Ensure ytest and ypred1 have the same length
ypred1 = ypred1[:len(ytest)]  # Adjust ypred1 to match ytest length if necessary

# Now you can create the scatter plot
plt.scatter(ytest, ypred1, alpha=0.5)
plt.xlabel("True Values")
plt.ylabel("Predicted Values")
plt.title("True vs. Predicted")

# ... (rest of your plotting code) ...
plt.scatter(ytest, ypred1, alpha=0.5)
plt.xlabel("True Values")
plt.ylabel("Predicted Values")
plt.title("True vs. Predicted")
plt.plot([min(ytest), max(ytest)], [min(ytest), max(ytest)], "r--")  # Diagonal line for reference
plt.show()

